#背景介绍
jedis连接单节点redis，在线程池中使用事务处理。

##参数
- 连接池大小：10
- 线程池大小：20
- 循环事务处理次数：2000

    `public TestClass{
		public void change(){
			makeChangeToRedis();
		}
		
		@Test
		public void test(){
			ThreadPoolExecutor executor = createThreadPoolExecutor();
			for(int i = 0; i < LoopNum; i ++)
				executor.execute(()->change());
		}
	}`

##问题现象
1. 当线程池比连接池小时200次循环没有问题。
1. 当线程池大于连接池且循环次数很大时，在运行过程中，处理速度回越来越慢，最终停止。如果不停止测试，最后会报错outofmemory，eden space为100%。

#目前现象
1. 如果运行时间够长，则报outpfmemory，eden space被占满。
1. 不使用线程池时，可运行较长时间，不会卡死，内存也不会溢出，速度也不会变慢。
1. 添加垃圾回收后，正常运行时间加长，阻塞时间点后延。

#遇到的问题
1. 使用JProfiler或visualvm连接测试用例的JVM，连接失败，猜测是因为内存已经不足，无法建立连接。
2. 在karaf环境中运行该部分代码，当循环次数较少时Heap堆被正常回收；当循环次数较多时，控制器卡死无反应。

#排查步骤
1. 因为无法从内存中查找到那些数据占用了eden space，因此首先使用单纯的Jedis操作Redis数据库，使用多线程大量操作。操作正常，程序无卡死现象，排除Jedis的问题。
2. 排查哪些地方创建了大量的对象，且不能被垃圾回收。发现在循环中调用executor.execute时，每次循环都创建一个Runnable对象。在循环过程中，不断创建Runnable对象，但是线程执行的速率小于for循环的速率，导致Runnable对象的个数在急剧上升。但是线程池的缓存队列很大，所以还是再不断创建Runnable对象，因此eden space满了，存放的都是Runnable对象。**修改方法：**1) 首先创建Runnable runnable = ()->change();2)然后在循环中调用execuor.execute(runnable)。
3. 在change中，每一次操作都需要两个Jedis链接，因为线程池个数大于Jedis连接池，所以会出现所有线程都获取不到第二个Jedis链接，所有线程都在等待，导致程序卡死。**修改方法**因为每个事务开始时都会去获取第一个链接，如果剩余链接数小于已经开始的事务个数，则不能开始事务，必须等待某个事务结束。

